<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>Raider (修正版)</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
  body { margin:0; min-height:100vh; background:#000; display:flex; justify-content:center; align-items:center; font-family:system-ui,sans-serif; color:#fee2e2; }
  .container { width:94%; max-width:620px; padding:28px; background:linear-gradient(145deg,#1a0000,#000); border-radius:20px; border:1px solid #7f1d1d; box-shadow:0 0 50px rgba(239,68,68,.4); }
  h1 { text-align:center; margin-bottom:28px; font-size:28px; background:linear-gradient(90deg,#fecaca,#ef4444,#7f1d1d); -webkit-background-clip:text; -webkit-text-fill-color:transparent; }
  label { display:block; margin-top:20px; font-size:15px; color:#fecaca; }
  textarea, input { width:100%; box-sizing:border-box; margin-top:8px; padding:14px; border-radius:14px; background:#000; color:#fee2e2; border:1px solid #7f1d1d; outline:none; font-size:15px; font-family:monospace; }
  textarea { resize:vertical; height:180px; }
  #message { height:120px; }
  .row { display:flex; gap:16px; margin-top:8px; }
  .row > div { flex:1; }
  .buttons { display:flex; gap:16px; margin-top:28px; }
  button { flex:1; padding:18px; font-size:17px; font-weight:bold; border-radius:16px; border:none; cursor:pointer; color:white; transition:all 0.3s; }
  #startBtn { background:linear-gradient(135deg,#16a34a,#22c55e); }
  #stopBtn { background:linear-gradient(135deg,#dc2626,#ef4444); opacity:0.7; }
  #stopBtn.active { opacity:1; }
  button:hover:not(:disabled) { transform:translateY(-2px); box-shadow:0 8px 25px rgba(0,0,0,0.5); }
  button:disabled { opacity:0.5; cursor:not-allowed; }
  .log { margin-top:24px; padding:16px; background:#111; border-radius:14px; border:1px solid #7f1d1d; max-height:300px; overflow-y:auto; font-size:14px; color:#fecaca; line-height:1.6; font-family:monospace; }
  .stats { margin-top:12px; text-align:center; font-size:15px; color:#fbbf24; font-weight:bold; }
  .error { color:#fca5a5; font-weight:bold; }
</style>
</head>
<body>
<div class="container">
  <h1>荒らし共栄圏 Raider (修正版)</h1>

  <label for="tokens">アカウントトークン (改行区切り)</label>
  <textarea id="tokens" placeholder="トークン複数可"></textarea>

  <div class="row">
    <div>
      <label for="delay">間隔 (ms)</label>
      <input type="number" id="delay" value="8000" min="3000">
    </div>
    <div>
      <label for="count">最大送信回数 (0=無限)</label>
      <input type="number" id="count" value="0" min="0">
    </div>
  </div>

  <div class="row">
    <div>
      <label for="guildId">サーバーID (任意)</label>
      <input type="text" id="guildId" placeholder="なくてもOK">
    </div>
    <div>
      <label for="channelId">チャンネルID (必須)</label>
      <input type="text" id="channelId" placeholder="例: 987654321098765432">
    </div>
  </div>

  <label for="message">メッセージ (必須)</label>
  <textarea id="message" maxlength="2000" placeholder="送信したい内容"></textarea>

  <div class="buttons">
    <button id="startBtn" onclick="startSending()">起動</button>
    <button id="stopBtn" onclick="stopSending()">停止</button>
  </div>

  <div class="stats" id="stats">成功: 0 回</div>
  <div class="log" id="log"></div>
</div>

<script>
const tokensEl = document.getElementById('tokens');
const delayEl = document.getElementById('delay');
const countEl = document.getElementById('count');
const channelEl = document.getElementById('channelId');
const messageEl = document.getElementById('message');
const logEl = document.getElementById('log');
const statsEl = document.getElementById('stats');
const startBtn = document.getElementById('startBtn');
const stopBtn = document.getElementById('stopBtn');

let isRunning = false;
let successCount = 0;
let tokenList = [];
let currentIndex = 0;
let sentCount = 0;

function log(msg, className = '') {
  logEl.innerHTML += `<span class="${className}">[${new Date().toLocaleTimeString('ja-JP',{hour12:false})}] ${msg}</span><br>`;
  logEl.scrollTop = logEl.scrollHeight;
}

function updateStats() {
  statsEl.textContent = `成功: ${successCount} 回 / 送信済: ${sentCount} 回`;
}

function stopSending() {
  isRunning = false;
  stopBtn.classList.remove('active');
  startBtn.disabled = false;
  log('停止しました');
}

async function sendMessage(token, channelId, content) {
  const uaList = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/130.0.0.0 Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0'
  ];
  const randomUA = uaList[Math.floor(Math.random() * uaList.length)];

  try {
    const res = await fetch(`https://discord.com/api/v10/channels/${channelId}/messages`, {
      method: 'POST',
      headers: {
        'Authorization': token.trim(),
        'Content-Type': 'application/json',
        'User-Agent': randomUA,
        'X-Super-Properties': 'eyJvcyI6IldpbmRvd3MiLCJicm93c2VyIjoiQ2hyb21lIiwiZGV2aWNlIjoiIiwic3lzdGVtX2xvY2FsZSI6ImphIn0=' // 適当な偽装（軽減用）
      },
      body: JSON.stringify({ content: content.trim() })
    });

    if (res.ok) {
      successCount++;
      updateStats();
      log(`成功 [トークン末尾...${token.slice(-6)}]`);
      return { success: true };
    }

    const headers = res.headers;
    const retryAfterHeader = headers.get('retry-after') || headers.get('Retry-After');
    let retryAfter = retryAfterHeader ? parseFloat(retryAfterHeader) * 1000 : 5000;

    if (res.status === 429) {
      try {
        const data = await res.json();
        retryAfter = (data.retry_after || 5) * 1000 + 2000;
        log(`429 Rate Limit → ${Math.round(retryAfter/1000)}秒待機`, 'error');
      } catch {}
      return { success: false, retry: true, wait: retryAfter };
    }

    let errMsg = `失敗 [${res.status}]`;
    if (res.status === 401) errMsg += ' → 無効/期限切れトークン';
    if (res.status === 403) errMsg += ' → 権限なし or BAN';
    if (res.status === 400) errMsg += ' → メッセージ内容不正';
    log(errMsg, 'error');

    return { success: false };
  } catch (e) {
    log(`ネットワークエラー: ${e.message} (CORS? ブロック? トークン無効?)`, 'error');
    return { success: false, network: true };
  }
}

async function startSending() {
  if (isRunning) return;
  logEl.innerHTML = '';
  successCount = sentCount = currentIndex = 0;
  updateStats();

  stopBtn.classList.add('active');
  startBtn.disabled = true;

  const rawTokens = tokensEl.value.trim();
  const delay = Math.max(3000, parseInt(delayEl.value) || 8000);
  const maxCount = parseInt(countEl.value) || 0;
  const channelId = channelEl.value.trim();
  const msg = messageEl.value.trim();

  if (!rawTokens || !channelId || !msg) {
    log('トークン / チャンネルID / メッセージ は必須', 'error');
    stopSending();
    return;
  }

  tokenList = rawTokens.split('\n').map(t => t.trim()).filter(t => t.length > 50 && t.includes('.'));

  if (tokenList.length === 0) {
    log('有効そうなトークンがありません', 'error');
    stopSending();
    return;
  }

  log(`トークン数: ${tokenList.length} | 間隔:${delay}ms | 最大:${maxCount||'∞'}回`);

  isRunning = true;

  while (isRunning && (maxCount === 0 || sentCount < maxCount)) {
    if (!isRunning) break;

    const token = tokenList[currentIndex % tokenList.length];
    currentIndex++;

    const result = await sendMessage(token, channelId, msg);

    sentCount++;

    if (result.retry) {
      await new Promise(r => setTimeout(r, result.wait || 10000));
      continue;
    }

    if (result.network) {
      // ネットワークエラー連発なら少し長めに待機
      await new Promise(r => setTimeout(r, 15000));
    }

    await new Promise(r => setTimeout(r, delay));
  }

  log('完了 or 停止');
  stopSending();
}
</script>
</body>
</html>
